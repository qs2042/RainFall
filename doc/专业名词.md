# 电商

## 模式

```text
B2B     Business to Business    商家与商家建立的商业关系, 如阿里巴巴
B2C     Business to Consumer    供应商直接将商品卖给用户, 商对客模式, 直接面向消费者销售产品和服务
                                如苏宁易购, 京东, 天猫, 小米商城, PDD(即商业零售)
C2B     Customer to Business    即消费者对企业, 先有消费者需求产生, 而后有企业按需求组织生产
C2C     Customer to Consumer    客户之间自己把东西放到网上去卖, 如淘宝和咸鱼
O2O     Online To Offline       将线下商务与互联网结合在一起, 让互联网成为线下交易的前台
                                线上快速支付, 线下优质服务, 如饿了么, 美团, 京东到家
```

## SPU, SKU

```
简介：
SPU：标准化产品单元 standard product unit, 是商品信息聚合的最小单位, 是一组可复用、易检索的标准化信息的集合, 该集合描述了一个产品的特性。

SKU：库存量单位 Stock Keeping Unit, 

SPU：iphone XS、iphone XS max、iphone XR、MI8、
SKU：iphonex 64G 黑曜石、MI8 8+64G+黑色

每个分类下的商品共享规格参数, 与销售属性。只是有些商品不一定要用这个分类下全部的属性;

属性是以三级分类组织起来的【attr关联分类id】
规格参数中有些是可以提供检索的
规格参数也是基本属性, 他们具有自己的分组
属性的分组也是以三级分类组织起来的
属性名确定的, 但是值是每一个商品不同来决定的【例如手机都有相同的基本属性, 只是值不同】

基本属性表：attr_id, search_type, attr_type属性类型（规格参数、销售属性）, catelog_id（三级分类）【demo：入网型号】
属性分组表：attr_group_id, catelog_id【demo：主体, 关联了 分类表。手机分类下有哪些分组】
属性+属性分组关联关系表：relation_id, attr_id, attr_group_id【1对多】

商品表spu_info：spu_id, spu_name, spu_description, catelog_id, brand_id
商品属性值表product_attr_value：id, spu_id, attr_id, attr_value属性值

商品库存表sku_info：sku_id, spu_id, price
销售属性值表sku_sale_attr_value：id, sku_id, attr_id, attr_value属性值【1对多】
```

# 微服务

```text
微服务架构的风格, 就像是把一个单独的应用程序开发为一套小服务
每个小服务只运行在自己的进程中, 并使用轻量级机制互相通信(通常是HTTP API)

这些服务围绕业务能力来构建, 并通过完全自动化部署机制来独立部署
这些服务使用不同的编程语言书写, 以及不同数据储存技术, 并保持最低限度的集中式管理

用人话来说就是: 
拒绝大型的单体应用, 基于业务边界进行服务微化拆分, 各个服务独立部署运行
```

SpringCloud文档: ...

SpringCloud Alibaba文档: https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md


## 集群 && 分布式 && 节点

```text
集群是物理形态的
    指的是将几台服务器集中在一起, 实现同一业务
    只要是一堆机器, 就可以叫集群
    (至于他们是不是一起协作着干活, 这个谁也不知道()

分布式是一种工作方式
    指的是将不同业务分布在不同的地方

节点
    集群中的一个服务器


例如京东就是一个分布式系统, 它众多的业务运行在不同机器上
所有业务构成了一个大型的业务集群
    机器1: 用户服务
    机器2: 商品服务
而每一个小的业务(例如用户系统), 当访问压力过大的时候, 一台服务器是不够的
这时应该将业务部署到多个服务器上(也就是每一个业务系统都可以做集群化)
分布式中的每一个节点, 都可以做集群, 而集群不一定就是分布式的
```

> <分布式系统原理与规范>  
> "分布式系统是若干独立计算机的集合, 这些计算机对于用户来说就像单个相关系统"  
> 分布式系统(Distributed System)是建立在网络之上的软件系统

## 远程调用

```text
在分布式系统中, 各个服务可能处于不同主机
但是服务之间不可避免的需要互相调用
而这就被称为远程调用

远程调用的方式有好几种, 这里就不过多阐述

在SpringCloud中通常使用HTTP+JSON的方式完成远程调用
```

## 负载均衡

```text

在分布式系统中, A服务需要调用B服务, 而B服务在多台机器中都存在
A调用任意一个服务器均可完成功能
为了使每一个服务器都不要太忙或者太闲
我们需要负载均衡的调用每一个服务器, 以此提升网站的健壮性


场景的负载均衡算法
=======================================
name       introduce
=======================================
轮询         为第一个请求选择健康池中的第一个后端服务器
            然后按照顺序往后依次选择, 直到最后一个, 然后循环
最小连接      优先选择连接数最少, 也就是压力最小的后端服务器
            在会话较长的情况下可以考虑采取这种方式
散列         根据请求源的IP的散列(hash), 来选择要转发的服务器
            这种方式可以一定程度上保证特定用户能连接到相同的服务器
            如果应用需要处理状态要求用户连接到和之前相同的服务器, 那么就可以用这种

假设A服务有一个, B服务有三个
轮询方式: 第一次B1, 第二次B2, 第三次B3, 第四次B1
最小连接: B1, B2, B3哪个连接数最少就选择哪个
散列方式: 广东IP选择B1, 广西IP选择B2, 湖北IP选择B3
```

## 服务注册 && 服务发现 && 注册中心

```text
A服务需要调用B服务, 但是A服务并不知道B服务当前在哪几台服务器有
也不知道那些服务是正常的, 那些那些服务已经下线
解决这个问题的方法之一: 引入注册中心

注册中心
↓
A1服务, A2服务, A3服务
B1服务, B2服务, B3服务
C1服务, C2服务, C3服务

服务注册: B服务上线后, 告知注册中心我上线了
服务发现: A服务想调用B服务, 去注册中心询问B服务在那台机器

```

## 配置中心

```text

[配置中心]
每一个服务最终都有大量的配置, 并且每个服务都可能部署在多台机器上
但是有时候需要经常变更配置, 我们可以让每个服务正在配置中心获取自己的配置

配置中心用来集中管理微服务的配置信息


```

## 网关(负载均衡, 服务自动熔断, 灰度发布, 统一认证, 限流监控, 日志统计)

```
API网关(API Gateway)在微服务的整体架构中, 是很重要组件
它抽象了微服务都需要的公共功能
同时提供了客户端以下功能: 
    负载均衡, 服务自动熔断, 灰度发布, 
    统一认证, 限流监控, 日志统计, 等丰富功能

client
↓
serviceId: login-repo
↓
API网关(API Gateway)
↓
统一认证, 限流监控, 日志统计, 灰度发布
↓
服务发现(Service Discovery)
↓
login-repo-A(192.168.1.4:8080)
login-repo-B(192.168.1.4:8081)
login-repo-C(192.168.1.4:8082)
↓
负载均衡, 服务自动熔断
↓
返回数据


在微服务架构中, 微服务之间通过网络进行通信, 这存在互相依赖
如果当其中一个服务不可用时, 就有可能会造成雪崩效应
为了防止这样子的情况出现, 必须要有容错机制来保护服务

A服务(订单) -> B服务(库存) -> C服务(支付)
假设
    B服务出现宕机, A服务就得等待B服务
    C服务出现宕机, A服务和B服务就得等待C服务
    BC服务都宕机了, A服务就得等待BC服务
重点不在于宕机, 而在于宕机的过程中
宕机的过程中, 用户在等待返回的数据, 服务器在等待服务恢复, 这就导致资源被占用
如果此时有更多的请求发过来, 那么多条请求就会堆积在一起, 造成请求积压

以下俩种方法可以解决这类问题
服务熔断
    设置服务的超时时间, 当被调用的服务经常失败到达某个阈值
    就可以开启断路保护机制, 后来的请求不再去调用这个服务
    本地直接返回默认的数据
服务降级    
    运维期间, 当系统处于高峰期, 系统资源紧缺, 我们可以让非核心业务降级运行
    这里的降级指: 某些服务不处理, 或简单处理
    (抛异常, 返回NULL, 调用Mock数据, 调用Fallback处理逻辑)


...



```

**RPS(Request Per Second)**

Spring Cloud Gateway 每秒能处理32213.38条请求

Zull的RPS为: 20800.13

Linkerd的RPS为: 28050

**网关的处理过程**

```text
gateway client
↓
gateway handler mapping
↓
gateway web handler
↓
filter1,filter2...
proxy filter
↓
proxied service
↓
gateway web handler
```

## 执行流程

```text
admin-vue, app, h5, react
↓
API网关 -> 路由, 过滤, 限流, 监控
↓
注册中心, 配置中心 -> xx服务, xx服务
```

# OSS

```text
[单体应用]
上传图片 -> 程序 -> 保存
读取图片 -> 程序 -> 读取

[微服务应用]
上传图片 -> 程序A -> 保存
读取图片 -> 程序B -> 读取 -> 读取失败(原因: 程序A在电脑A中. 程序B在电脑B中)

[微服务 + OSS: 简单上传]
上传图片 -> API网关 -> 微服务(文件内容) -> OSS -> 保存
# 不推荐这种, 用户上传文件到微服务, 微服务再转发给OSS进行保存, 会多消耗一次读取文件的流量

[微服务 + OSS: Web签名上传]
上传图片 -> API网关 -> 微服务(签名数据) -> OSS -> 保存
# 推荐使用这种, 用户直接拿着从微服务获得的签名直接去找OSS保存文件就好了
```

# Java

1. PO（Persistent Object）, 持久化对象, 主要用于持久化层, 与数据库表结构一一对应, 通过DAO层向上传输数据源对象。
2. DTO(Data Transfer Object), 数据传输对象, Service或Manager向外传输的对象
3. VO（View object）, 视图对象, 接收页面请求数据封装的对象,  封装返回给页面的对象
4. BO（business object）业务对象, 由多个不同类型的PO组成, 例如一个简历对象, 由教育经历PO, 工作经历PO组成
5. POJO（plain ordinary java object）简单无规则java对象, 是 PO/DTO/BO/VO的统称, 只有基本的setter、getter方法
6. DAO（data access object）数据访问对象是一个sun的一个标准j2ee
   设计模式, 这个模式中有个接口就是DAO, 它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用, DAO中包含了各种数据库的操作方法。通过它的方法, 结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合vo, 提供数据库的
   CRUD 操作.

# 前端

**ES6**
前端语言的规范

每年都会发布一个新的标准

例如 ECMAScript 2018（也被称为 ES9）, 这些标准带来了新的语法特性和功能。

**Node.js**
基于 Chrome V8 引擎的 JavaScript 运行时环境, 用于在服务器端运行 JavaScript

它提供了许多内置模块和工具, 使开发者能够构建高性能的服务器端应用程序

**npm**
是 Node.js 的包管理工具, 类似于 Java 中的 Maven。

它允许开发者轻松地安装、管理和共享 JavaScript 包和模块。

**Vue**
相当于springmvc

**Babel**
是一个javascript编译器, 自动转换为浏览器兼容的代码

**webpack**
自动化项目构建工具, gulp也是同类产品

# 系统

## ERP（Enterprise Resource Planning）

企业资源规划, 是一种综合性的企业管理系统, 用于管理和协调企业各个部门的业务流程和信息, 包括采购、销售、库存管理、财务管理等。

## CMS（Content Management System）

内容管理系统, 是一种用于创建、编辑、组织和发布数字内容的软件系统。

它通常用于网站和博客的内容管理, 以便用户可以轻松管理和发布内容。

## CRM（Customer Relationship Management）

客户关系管理, 是一种管理和优化与客户互动的方法和工具。

CRM 系统帮助企业跟踪客户信息、管理销售流程、提供客户支持, 并增强客户关系。

## HRM（Human Resource Management）

人力资源管理, 是一种管理和优化企业人力资源的方法和流程。

HRM 系统帮助企业招聘、培训、绩效管理、薪酬管理和员工福利等人力资源管理活动。

## BI（Business Intelligence）

商业智能, 是一种利用数据分析和信息可视化技术来支持企业决策的方法和工具。

BI 系统帮助企业从大量数据中提取有用的洞察, 并帮助管理层做出更明智的决策。

## SCM（Supply Chain Management）

供应链管理, 是一种管理和优化供应链活动的方法和流程。

SCM 系统帮助企业管理供应商关系、物流、库存和供应链协调, 以确保产品或服务的顺利交付。

## EAM（Enterprise Asset Management）

企业资产管理, 是一种管理和维护企业资产的方法和流程。

EAM 系统帮助企业管理设备、机器和其他资产的使用、维护、故障修复和替换。

## WMS（Warehouse Management System）

仓库管理系统, 是一种用于管理和优化仓库运营的软件系统。

WMS 系统帮助企业管理库存、入库、出库、订单处理以及仓库资源的分配和优化。

## OA（Office Automation）

办公自动化, 是一种利用计算机和软件技术来提高办公效率和流程自动化的方法。

OA 系统可以涵盖各种办公活动, 如电子邮件、日程安排、文档管理、工作流程等。

# Web

## 动静分离

传统的 java web 都是一个服务器来处理动态资源和静态资源

如果静态资源全都存储在Tomcat中, 所有静态资源都要从Tomcat获取

会因为静态资源, 导致占用Tomcat很多线程来处理

动静分离, 表示将资源与web服务器分离, 可存放在nginx中, 静态资源直接从nginx中返回

## 前后端分离

## session, springSession

**session**
0. 浏览器存储一个cookie值，jsessionId作为key
0. 浏览器请求服务器时会带上这个cookie，服务器根据jsessionId的值找到对应的session对象
0. 从而可以拿到session中存储的信息（例如用户信息）
0. session对象存储在内存中

**springSession**
0. 通过CookieSerializer设置cookie相关信息，setCookieName设置cookie的key值（代替jsessionId），并自动生成value值，并且可以setDomainName放大作用域
0. springsession将session对象存储在redis中

# OAuth

OAuth(开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息

而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。

不过现在都使用OAuth2.0协议了

OAuth实际上就是服务器开放了一些查询用户信息的OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等）

为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权

授权成功会拿到token，根据token调用OpenAPI获取用户信息

0. 用户在C端申请认证(跳转到D端登录页面)
0. 用户授权(输入账号密码)
0. 授权成功(D端返回访问令牌)
0. 使用令牌(C端会使用令牌向D端获取用户的信息)
0. 展示信息(D端认证令牌后会返回用户的信息)

使用Code换区AccessToken, Code只能用一次

同一个用户的AccessToken一段时间是不会变化的, 即便多次获取



# 
仓库服务

0. 商品: 商品类别, 商品信息, 计量单位, 商品标签
0. 生产: 生产任务, 委托任务, 生产调度, 物料管理, BOM管理
0. 仓库: 入库出库, 物流记录, 配送记录, 库存管理
0. 采购: 采购计划, 采购订单, 入库记录, 退货记录

销售服务

0. 零售/批发: 零售订单, 退货订单

财务服务

0. 财务管理: 收入支出, 付款收款, 账单记录, 预付款记录, 固定资产, 成本管理
0. 报表管理: 商品/账户/零售/采购/销售/入库/出库/调拨/进销统计, 客户对账, 供应商对账